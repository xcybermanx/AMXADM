#!/bin/bash
[[ $1 != "" ]] && id="$1" || id="en"
barra="\033[1;34m =================================== \033[1;37m"
_cores="./cores"
_dr="./idioma"
[[ "$(echo ${txt[0]})" = "" ]] && source idioma_geral

#LIST PORTS
mportas () {
unset portas
portas_var=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" |grep -v "COMMAND" | grep "LISTEN")
while read port; do
var1=$(echo $port | awk '{print $1}') && var2=$(echo $port | awk '{print $9}' | awk -F ":" '{print $2}')
[[ "$(echo -e $portas|grep "$var1 $var2")" ]] || portas+="$var1 $var2\n"
done <<< "$portas_var"
i=1
echo -e "$portas"
}

#MY IP
fun_ip () {
MEU_IP=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)
MEU_IP2=$(wget -qO- ipv4.icanhazip.com)
[[ "$MEU_IP" != "$MEU_IP2" ]] && IP="$MEU_IP2" || IP="$MEU_IP"
}

# CLOUDFLARE TUNNEL WITH CLOUDFLARED
add_cloudflare_tunnel() {
    echo -e "$barra"
    echo -e "\033[1;36m SETUP CLOUDFLARE TUNNEL\033[0m"
    echo -e "$barra"
    
    # Check if cloudflared is already running
    if pgrep cloudflared > /dev/null; then
        echo -e "\033[1;33m Cloudflared is already running. Stopping...\033[0m"
        pkill cloudflared
        sleep 2
    fi

    # Install cloudflared
    echo -e "\033[1;33m Installing cloudflared...\033[0m"
    
    # Detect architecture
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="amd64" ;;
        aarch64) ARCH="arm64" ;;
        armv7l) ARCH="arm" ;;
        *) ARCH="amd64" ;;
    esac

    # Download and install cloudflared
    cd /tmp
    wget -q "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-$ARCH" -O cloudflared
    chmod +x cloudflared
    mv cloudflared /usr/local/bin/
    
    echo -e "\033[1;32m Cloudflared installed successfully\033[0m"
    
    # Setup options
    echo -e "$barra"
    echo -e "\033[1;33m Choose tunnel type:\033[0m"
    echo -e " 1) HTTP/HTTPS Tunnel (Port 80/443)"
    echo -e " 2) SSH Tunnel (Port 22)"
    echo -e " 3) Custom Port Tunnel"
    echo -e " 4) DNS Tunnel"
    read -p " Select [1-4]: " tunnel_type
    
    case $tunnel_type in
        1)
            TUNNEL_PORT="80"
            SERVICE_TYPE="http"
            ;;
        2)
            TUNNEL_PORT="22"
            SERVICE_TYPE="ssh"
            ;;
        3)
            read -p " Enter custom port: " TUNNEL_PORT
            SERVICE_TYPE="http"
            ;;
        4)
            SERVICE_TYPE="dns"
            ;;
        *)
            echo -e "\033[1;31m Invalid selection\033[0m"
            return 1
            ;;
    esac

    # Setup tunnel
    if [[ $SERVICE_TYPE != "dns" ]]; then
        echo -e "\033[1;33m Starting Cloudflare tunnel on port $TUNNEL_PORT...\033[0m"
        
        # Run cloudflared tunnel
        screen -dmS cloudflared-tunnel cloudflared tunnel --url http://localhost:$TUNNEL_PORT
        
        echo -e "\033[1;32m Cloudflare tunnel started successfully!\033[0m"
        echo -e "\033[1;36m Tunnel URL: https://web.goinit.space\033[0m"
        echo -e "\033[1;36m Local port: $TUNNEL_PORT\033[0m"
    else
        echo -e "\033[1;33m Starting DNS over HTTPS...\033[0m"
        screen -dmS cloudflared-dns cloudflared proxy-dns --port 5054
        echo -e "\033[1;32m DNS over HTTPS started on port 5054\033[0m"
    fi
    
    echo -e "$barra"
    return 0
}

# WEBSERVER WITH SSL
setup_webserver() {
    echo -e "$barra"
    echo -e "\033[1;36m SETUP WEB SERVER WITH SSL\033[0m"
    echo -e "$barra"
    
    # Install nginx
    echo -e "\033[1;33m Installing nginx...\033[0m"
    apt-get update > /dev/null 2>&1
    apt-get install -y nginx > /dev/null 2>&1
    
    # Create web directory
    WEB_DIR="/var/www/html"
    mkdir -p $WEB_DIR
    
    # Create basic index page
    cat > $WEB_DIR/index.html << EOF
<!DOCTYPE html>
<html>
<head>
    <title>Welcome to $(hostname)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 800px; margin: 0 auto; }
        .status { background: #f4f4f4; padding: 20px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Welcome to $(hostname)</h1>
        <div class="status">
            <h3>Server Status: <span style="color: green;">Online</span></h3>
            <p><strong>IP Address:</strong> $IP</p>
            <p><strong>Hostname:</strong> $(hostname)</p>
            <p><strong>Uptime:</strong> $(uptime -p)</p>
        </div>
    </div>
</body>
</html>
EOF

    # Setup nginx with SSL
    cat > /etc/nginx/sites-available/default << EOF
server {
    listen 80;
    listen [::]:80;
    server_name _;
    return 301 https://\$host\$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    
    root $WEB_DIR;
    index index.html index.htm;
    
    location / {
        try_files \$uri \$uri/ =404;
    }
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
}
EOF

    # Generate self-signed SSL certificate
    openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
        -keyout /etc/ssl/private/nginx-selfsigned.key \
        -out /etc/ssl/certs/nginx-selfsigned.crt \
        -subj "/C=US/ST=State/L=City/O=Organization/CN=$(hostname)" > /dev/null 2>&1

    # Start nginx
    systemctl enable nginx > /dev/null 2>&1
    systemctl restart nginx > /dev/null 2>&1
    
    echo -e "\033[1;32m Web server setup completed!\033[0m"
    echo -e "\033[1;36m Access via: http://$IP\033[0m"
    echo -e "\033[1;36m Or via: https://$IP (self-signed cert)\033[0m"
    echo -e "$barra"
}

# SERVER MONITORING
server_monitor() {
    echo -e "$barra"
    echo -e "\033[1;36m SERVER MONITORING\033[0m"
    echo -e "$barra"
    
    # Display system information
    echo -e "\033[1;33m === SYSTEM INFORMATION ===\033[0m"
    echo -e " Hostname: $(hostname)"
    echo -e " OS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '\"')"
    echo -e " Uptime: $(uptime -p)"
    echo -e " Load: $(uptime | awk -F'load average:' '{print $2}')"
    
    echo -e "\n\033[1;33m === CPU INFORMATION ===\033[0m"
    echo -e " CPU Model: $(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)"
    echo -e " CPU Cores: $(nproc)"
    echo -e " CPU Usage: $(top -bn1 | grep "Cpu(s)" | awk '{print 100 - $8"%"}')"
    
    echo -e "\n\033[1;33m === MEMORY INFORMATION ===\033[0m"
    free -h | awk '
    /Mem:/ {
        printf " Total: %s | Used: %s | Free: %s | Usage: %.2f%%\n", 
        $2, $3, $4, ($3/$2)*100
    }'
    
    echo -e "\n\033[1;33m === DISK USAGE ===\033[0m"
    df -h / | awk 'NR==2 {printf " Total: %s | Used: %s | Free: %s | Usage: %s\n", $2, $3, $4, $5}'
    
    echo -e "\n\033[1;33m === NETWORK INFORMATION ===\033[0m"
    echo -e " Public IP: $IP"
    echo -e " Active Connections: $(netstat -an | grep ESTABLISHED | wc -l)"
    
    echo -e "\n\033[1;33m === ACTIVE SERVICES ===\033[0m"
    services=("ssh" "squid" "dropbear" "openvpn" "nginx" "stunnel4")
    for service in "${services[@]}"; do
        if systemctl is-active --quiet $service 2>/dev/null || pgrep $service >/dev/null; then
            echo -e " $service: \033[1;32mACTIVE\033[0m"
        else
            echo -e " $service: \033[1;31mINACTIVE\033[0m"
        fi
    done
    
    echo -e "$barra"
    read -p " Press Enter to continue..."
}

# FIREWALL SETUP
setup_firewall() {
    echo -e "$barra"
    echo -e "\033[1;36m FIREWALL CONFIGURATION\033[0m"
    echo -e "$barra"
    
    # Install ufw if not present
    if ! command -v ufw > /dev/null; then
        echo -e "\033[1;33m Installing UFW firewall...\033[0m"
        apt-get install -y ufw > /dev/null 2>&1
    fi
    
    # Reset firewall
    ufw --force reset > /dev/null 2>&1
    
    # Default policies
    ufw default deny incoming > /dev/null 2>&1
    ufw default allow outgoing > /dev/null 2>&1
    
    # Allow essential ports
    essential_ports=("22" "80" "443" "1194" "3128" "8080")
    for port in "${essential_ports[@]}"; do
        ufw allow $port/tcp > /dev/null 2>&1
    done
    
    # Allow additional services
    ufw allow 442/tcp > /dev/null 2>&1  # Dropbear
    ufw allow 53/udp > /dev/null 2>&1   # DNS
    
    # Enable firewall
    echo "y" | ufw enable > /dev/null 2>&1
    
    echo -e "\033[1;32m Firewall configured successfully!\033[0m"
    echo -e "\033[1;36m Allowed ports: ${essential_ports[*]}\033[0m"
    echo -e "$barra"
}

# BACKUP SYSTEM
backup_system() {
    echo -e "$barra"
    echo -e "\033[1;36m SYSTEM BACKUP\033[0m"
    echo -e "$barra"
    
    BACKUP_DIR="/root/backups"
    BACKUP_FILE="backup-$(date +%Y%m%d-%H%M%S).tar.gz"
    mkdir -p $BACKUP_DIR
    
    echo -e "\033[1;33m Creating system backup...\033[0m"
    
    # Backup important directories
    tar -czf $BACKUP_DIR/$BACKUP_FILE \
        /etc/ssh/ \
        /etc/squid/ \
        /etc/squid3/ \
        /etc/openvpn/ \
        /etc/dropbear/ \
        /etc/stunnel/ \
        /root/ \
        /var/www/ \
        2>/dev/null
    
    if [[ $? -eq 0 ]]; then
        echo -e "\033[1;32m Backup created successfully!\033[0m"
        echo -e "\033[1;36m Backup file: $BACKUP_DIR/$BACKUP_FILE\033[0m"
        echo -e "\033[1;36m Size: $(du -h $BACKUP_DIR/$BACKUP_FILE | cut -f1)\033[0m"
    else
        echo -e "\033[1;31m Backup creation failed!\033[0m"
    fi
    
    echo -e "$barra"
}

# SYSTEM OPTIMIZATION
optimize_system() {
    echo -e "$barra"
    echo -e "\033[1;36m SYSTEM OPTIMIZATION\033[0m"
    echo -e "$barra"
    
    echo -e "\033[1;33m Applying system optimizations...\033[0m"
    
    # Update system
    apt-get update > /dev/null 2>&1
    apt-get upgrade -y > /dev/null 2>&1
    
    # Install useful tools
    apt-get install -y \
        htop \
        nethogs \
        iotop \
        iftop \
        screen \
        curl \
        wget \
        unzip > /dev/null 2>&1
    
    # Optimize sysctl settings
    cat >> /etc/sysctl.conf << EOF

# Performance optimizations
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1
net.ipv4.tcp_no_metrics_save = 1
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.tcp_syncookies = 1

# Security optimizations
net.ipv4.ip_forward = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
EOF

    # Apply changes
    sysctl -p > /dev/null 2>&1
    
    echo -e "\033[1;32m System optimization completed!\033[0m"
    echo -e "$barra"
}

#ETHTOOL SSH
fun_eth () {
eth=$(ifconfig | grep -v inet6 | grep -v lo | grep -v 127.0.0.1 | grep "encap:Ethernet" | awk '{print $1}')
    [[ $eth != "" ]] && {
    echo -e "$barra"
    echo -e "${cor[3]} Apply System to Improve SSH Packets?"
    echo -e "${cor[3]} Option For Advanced Users"
    echo -e "$barra"
    read -p " [S/N]: " -e -i n sshsn
           [[ "$sshsn" = @(s|S|y|Y) ]] && {
           echo -e "${cor[1]} Fixing SSH packet problems..."
           echo -e " What RX Rate"
           echo -ne "[ 1 - 999999999 ]: "; read rx
           [[ "$rx" = "" ]] && rx="999999999"
           echo -e " What TX Rate"
           echo -ne "[ 1 - 999999999 ]: "; read tx
           [[ "$tx" = "" ]] && tx="999999999"
           apt-get install ethtool -y > /dev/null 2>&1
           ethtool -G $eth rx $rx tx $tx > /dev/null 2>&1
           }
     echo -e "$barra"
     }
}

#FUN_BAR
fun_bar () {
comando[0]="$1"
comando[1]="$2"
 (
[[ -e $HOME/fim ]] && rm $HOME/fim
${comando[0]} -y > /dev/null 2>&1
${comando[1]} -y > /dev/null 2>&1
touch $HOME/fim
 ) > /dev/null 2>&1 &
echo -ne "\033[1;33m ["
while true; do
   for((i=0; i<18; i++)); do
   echo -ne "\033[1;31m##"
   sleep 0.1s
   done
   [[ -e $HOME/fim ]] && rm $HOME/fim && break
   echo -e "\033[1;33m]"
   sleep 1s
   tput cuu1
   tput dl1
   echo -ne "\033[1;33m ["
done
echo -e "\033[1;33m]\033[1;31m -\033[1;32m 100%\033[1;37m"
}

# [Include all your existing functions here: fun_squid, fun_dropbear, instala_ovpn, etc.]
# [They remain the same as in your original script]

#FUNCTIONS
funcao_addcores () {
if [ "$1" = "0" ]; then
cor[$2]="\033[0m"
elif [ "$1" = "1" ]; then
cor[$2]="\033[1;31m"
elif [ "$1" = "2" ]; then
cor[$2]="\033[1;32m"
elif [ "$1" = "3" ]; then
cor[$2]="\033[1;33m"
elif [ "$1" = "4" ]; then
cor[$2]="\033[1;34m"
elif [ "$1" = "5" ]; then
cor[$2]="\033[1;35m"
elif [ "$1" = "6" ]; then
cor[$2]="\033[1;36m"
elif [ "$1" = "7" ]; then
cor[$2]="\033[1;37m"
fi
}

[[ -e $_cores ]] && {
_cont="0"
while read _cor; do
funcao_addcores ${_cor} ${_cont}
_cont=$(($_cont + 1))
done < $_cores
} || {
cor[0]="\033[0m"
cor[1]="\033[1;34m"
cor[2]="\033[1;32m"
cor[3]="\033[1;37m"
cor[4]="\033[1;36m"
cor[5]="\033[1;33m"
cor[6]="\033[1;35m"
}

# Check service status
unset squid dropbear openvpn stunel shadow telegran socks gettun tcpbypass webminn ddos
[[ -e /etc/squid/squid.conf ]] && squid="\033[1;32mOnline"
[[ -e /etc/squid3/squid.conf ]] && squid="\033[1;32mOnline"
[[ -e /etc/default/dropbear ]] && dropbear="\033[1;32mOnline"
[[ -e /etc/openvpn/server.conf ]] && openvpn="\033[1;32mConfigured"
[[ $(mportas|grep stunnel4|head -1) ]] && stunel="\033[1;32mOnline"
[[ -e /etc/shadowsocks.json ]] && shadow="\033[1;32mOnline"
[[ "$(ps x | grep "ultimatebot" | grep -v "grep")" != "" ]] && telegran="\033[1;32mOnline"
[[ -e /etc/adm-lite/sockson ]] && socks="\033[1;32mOnline"
[[ -e /etc/adm-lite/gettun ]] && gettun="\033[1;32mOnline"
[[ -e /etc/adm-lite/edbypass ]] && tcpbypass="\033[1;32mOnline"
[[ -e /etc/webmin/miniserv.conf ]] && webminn="\033[1;32mOnline"
[[ -e /usr/local/ddos/ddos.conf ]] && ddos="\033[1;32mOnline"

# Check new services
[[ $(pgrep cloudflared) ]] && cloudflared_status="\033[1;32mOnline" || cloudflared_status="\033[1;31mOffline"
[[ $(systemctl is-active nginx) == "active" ]] && nginx_status="\033[1;32mOnline" || nginx_status="\033[1;31mOffline"

# MAIN MENU
echo -e "$barra"
echo -e "${cor[5]} ADVANCED SERVER MANAGEMENT SCRIPT"
echo -e "$barra"
echo -e "${cor[2]} [1]  > ${cor[3]}SQUID $squid"
echo -e "${cor[2]} [2]  > ${cor[3]}DROPBEAR $dropbear"
echo -e "${cor[2]} [3]  > ${cor[3]}OPENVPN $openvpn"
echo -e "${cor[2]} [4]  > ${cor[3]}SSL TUNNEL $stunel"
echo -e "${cor[2]} [5]  > ${cor[3]}SHADOW SOCKS $shadow"
echo -e "${cor[2]} [6]  > ${cor[3]}PROXY SOCKS $socks"
echo -e "${cor[2]} [7]  > ${cor[3]}PROXY GETTUNEL $gettun"
echo -e "${cor[2]} [8]  > ${cor[3]}TCP OVER BYPASS $tcpbypass"
echo -e "${cor[2]} [9]  > ${cor[3]}TELEGRAM MANAGER BOT $telegran"
echo -e "${cor[2]} [10] > ${cor[3]}WEBMIN $webminn"
echo -e "${cor[2]} [11] > ${cor[3]}Anti-DDOS $ddos"
echo -e "${cor[2]} [12] > ${cor[3]}V2RAY"
echo -e "${cor[2]} [13] > ${cor[3]}ZIVPN"
echo -e "${cor[2]} [14] > ${cor[3]}CLOUDFLARE TUNNEL $cloudflared_status"
echo -e "${cor[2]} [15] > ${cor[3]}WEB SERVER (NGINX) $nginx_status"
echo -e "${cor[2]} [16] > ${cor[3]}SERVER MONITORING"
echo -e "${cor[2]} [17] > ${cor[3]}FIREWALL SETUP"
echo -e "${cor[2]} [18] > ${cor[3]}SYSTEM BACKUP"
echo -e "${cor[2]} [19] > ${cor[3]}SYSTEM OPTIMIZATION"
echo -e "$barra"
echo -ne "\033[1;37m Select an option: "
read optons
case $optons in
1) fun_squid; read -p " Enter";;
2) fun_dropbear; read -p " Enter";;
3) fun_openvpn; read -p " Enter";;
4) ssl_stunel; read -p " Enter";;
5) fun_shadowsocks; read -p " Enter";;
6) iniciarsocks; read -p " Enter";;
7) gettunel_fun; read -p " Enter";;
8) tcpbypass_fun; read -p " Enter";;
9) telegran_bot; read -p " Enter";;
10) web_min; read -p " Enter";;
11) antiddos; read -p " Enter";;
12) fun_v2ray; read -p " Enter";;
13) fun_zivpn; read -p " Enter";;
14) add_cloudflare_tunnel; read -p " Enter";;
15) setup_webserver; read -p " Enter";;
16) server_monitor; read -p " Enter";;
17) setup_firewall; read -p " Enter";;
18) backup_system; read -p " Enter";;
19) optimize_system; read -p " Enter";;
esac

#Restart ADM
menu
